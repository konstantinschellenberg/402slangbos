library(ggplot2)
library(openair)
library(readxl)
library(scales)
library(cowplot)
library(rts)
library(sf)
library(dplyr)
s1_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VH_free_state_study_area_geo402"
s1 = brick(s1_path)
crs(s1)
ncell(s1)
dim(s1)
res(s1)
n = nlayers(s1)
roi_path = "D:\\Geodaten\\#Jupiter\\GEO402\\02_features\\ROI_updated.kml"
# make spatial subset with ROI bounds
roi = readOGR(roi_path, "ROI_updated")
class(roi)
crs(roi)
plot(roi, axes = TRUE, col="blue")
#convert to sf object (S4)
sf_roi = st_as_sf(roi)
# set crs of s1 layer
st_transform(sf_roi, st_crs(s1))
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
roi_increase_1 = roi_increase[1,1]
plot(roi_increase_1, main = "1")
plot(roi_increase[1,1], main = "1")
plot(roi_increase[1,1], main = "Increase")
?plot
# here: iteration through polygons and writing to df
subset = extract(s1, roi_increase[1,1])
# convert to dataframe
df = as.data.frame(subset)
roi_increase
class(roi_increase)
class(df)
# convert band names to date
bandnames = names(df)
# iterate for date in column-names
for (i in bandnames){
date = substr(bandnames,13,20)
}
# convert date string into R date-time format
date_s1 = c()
for (i in 1:length(date)){
date_s1 <- append(date_s1, as.POSIXct(date[i], format = "%Y%m%d")) #https://www.statmethods.net/input/dates.html
}
date_s1
View(subset)
View(df)
t(df)
View(df)
df = t(df)
df
head(df)
View(df)
df = t(df)
head(df)
View(df)
library(zoo)
z <- read.zoo(text = Lines, header = TRUE, format = "%m/%d/%Y")
a = xts(df)
a = xts(df, order.by = date_s1)
df = t(df)
head(df)
a = xts(df, order.by = date_s1)
View()
View(a)
df %>%
t() %>%
head() %>%
xts(order.by = date_s1) %>%
t() %>%
head()
# make spatial subset with ROI bounds
roi = readOGR(roi_path, "ROI_updated")
class(roi)
crs(roi)
plot(roi, axes = TRUE, col="blue")
#convert to sf object (S4)
sf_roi = st_as_sf(roi)
# set crs of s1 layer
st_transform(sf_roi, st_crs(s1))
# make spatial subset with ROI bounds
roi = readOGR(roi_path, "ROI_updated")
class(roi)
crs(roi)
plot(roi, axes = TRUE, col="blue")
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1))
sf_roi
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1)) %>%
plot()
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1)) %>%
plot([1])
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1)) %>%
# --------------------subset to the first ROI-----------------------------------
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
plot(roi_increase[1,1], main = "Increase")
# here: iteration through polygons and writing to df
#
subset = extract(s1, roi_increase[1,1])
# convert to dataframe
df = as.data.frame(subset)
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1)) %>%
# --------------------subset to the first ROI-----------------------------------
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
# make spatial subset with ROI bounds
roi = readOGR(roi_path, "ROI_updated")
class(roi)
crs(roi)
plot(roi, axes = TRUE, col="blue")
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1)) %>%
# --------------------subset to the first ROI-----------------------------------
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
plot(roi_increase[1,1], main = "Increase")
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1)) %>%
# --------------------subset to the first ROI-----------------------------------
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
class(sf_roi)
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1))
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
plot(roi_increase[1,1], main = "Increase")
class(sf_roi)
# here: iteration through polygons and writing to df
#
subset = extract(s1, roi_increase[1,1])
# convert to dataframe
df = as.data.frame(subset)
# convert band names to date
bandnames = names(df)
# iterate for date in column-names
for (i in bandnames){
date = substr(bandnames,13,20)
}
# convert date string into R date-time format
date_s1 = c()
for (i in 1:length(date)){
date_s1 <- append(date_s1, as.POSIXct(date[i], format = "%Y%m%d")) #https://www.statmethods.net/input/dates.html
}
date_s1
df %>%
t() %>%
head() %>%
xts(order.by = date_s1) %>%
t() %>%
head()
View(df)
a=df %>%
t() %>%
head() %>%
a %>%
xts(order.by = date_s1) %>%
t() %>%
head()
a = df %>%
t() %>%
head()
a
View(a)
a = df %>%
t() %>%
head()
a = df %>%
t()
View(a)
a = df %>%
t() %>%
xts(order.by = date_s1) %>%
t()
View(a)
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t() %>%
for (line in nrow(date_df))
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t()
View(df)
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t()
View(date_df)
rownames(df)
rownames(df)[1]
date_s1
class(date_df)
asdf = as.data.frame(date_df)
View(asdf)
class(asdf)
# integrate date to dataset: making time series
# hereby the table needs to be transposed temporarily as xts()`
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t() %>%
as.data.frame()
# load required packages
library(raster)
library(dplyr)
library(reshape2)
library(rgdal)
library(ggplot2)
library(openair)
library(readxl)
library(scales)
library(cowplot)
library(rts)
library(sf)
library(dplyr)
s1_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VH_free_state_study_area_geo402"
s1 = brick(s1_path)
crs(s1)
ncell(s1)
dim(s1)
res(s1)
n = nlayers(s1)
roi_path = "D:\\Geodaten\\#Jupiter\\GEO402\\02_features\\ROI_updated.kml"
# make spatial subset with ROI bounds
roi = readOGR(roi_path, "ROI_updated")
class(roi)
crs(roi)
plot(roi, axes = TRUE, col="blue")
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1))
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
plot(roi_increase[1,1], main = "Increase")
# here: iteration through polygons and writing to df
#
subset = extract(s1, roi_increase[1,1])
# convert to dataframe
df = as.data.frame(subset)
# convert band names to date
bandnames = names(df)
# iterate for date in column-names
for (i in bandnames){
date = substr(bandnames,13,20)
}
# convert date string into R date-time format
date_s1 = c()
for (i in 1:length(date)){
date_s1 <- append(date_s1, as.POSIXct(date[i], format = "%Y%m%d")) #https://www.statmethods.net/input/dates.html
}
date_s1
View(df)
# integrate date to dataset: making time series
# hereby the table needs to be transposed temporarily as `xts()` orders by rows
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t() %>%
as.data.frame()
head(date_df)
?head()
?head
head(date_df, 5)
head(date_df, 0)
head(date_df, 1)
head(date_df, 5)
head(date_df[, 1:5], 5)
head(date_df[, 1:2], 5)
head(date_df[, 1:2], 10)
tail(date_df[, -1]), 10)
tail(date_df[, 1]), 10)
tail(date_df, 10)
tail(date_df[1], 10)
plot(date_df, axes = TRUE)
plot(date_df, axis = TRUE)
plot(date_df)
plot(date_df, add = FALSE)
plot(date_df[1], add = FALSE)
plot(date_df[3], add = FALSE)
plot(date_df[5], add = FALSE)
plot(date_df[1:10], add = FALSE)
View(df)
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t()
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
dplyr::transmute(mean)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
dplyr::mutate(mean)
?mutate
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
dplyr::mutate(mean, na.rm = TRUE)
CLASS(df)
class(df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
dplyr::mutate(mean, na.rm = TRUE)
??cowplot
?mapply(function, ...)
?map
library(purrr)
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
purrr::map_dbl(mean)
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
purrr::map(mean)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
map(mean)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
map(mean)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
map_df(mean)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
map_df(mean)
df
# convert to dataframe
df = as.data.frame(subset)
# load required packages
library(raster)
library(dplyr)
library(reshape2)
library(rgdal)
library(ggplot2)
library(openair)
library(readxl)
library(scales)
library(cowplot)
library(rts)
library(sf)
library(purrr)
s1_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VH_free_state_study_area_geo402"
s1 = brick(s1_path)
crs(s1)
ncell(s1)
dim(s1)
res(s1)
n = nlayers(s1)
roi_path = "D:\\Geodaten\\#Jupiter\\GEO402\\02_features\\ROI_updated.kml"
# make spatial subset with ROI bounds
roi = readOGR(roi_path, "ROI_updated")
class(roi)
crs(roi)
plot(roi, axes = TRUE, col="blue")
sf_roi = roi %>%
st_as_sf() %>%
st_transform(st_crs(s1))
# get object with name = 1
roi_increase = sf_roi %>%
filter(sf_roi$Name == 1)
plot(roi_increase[1,1], main = "Increase")
# here: iteration through polygons and writing to df
#
subset = extract(s1, roi_increase[1,1])
# convert to dataframe
df = as.data.frame(subset)
# convert band names to date
bandnames = names(df)
# iterate for date in column-names
for (i in bandnames){
date = substr(bandnames,13,20)
}
# convert date string into R date-time format
date_s1 = c()
for (i in 1:length(date)){
date_s1 <- append(date_s1, as.POSIXct(date[i], format = "%Y%m%d")) #https://www.statmethods.net/input/dates.html
}
date_s1
# integrate date to dataset: making time series
# hereby the table needs to be transposed temporarily as `xts()` orders by rows
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t() %>%
as.data.frame()
df
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
map_df(mean)
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
map_df(mean)
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
map_df(mean)
View(date_grouped_df)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame() %>%
transmute(mean = map_df(mean))
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame() %>%
transmute(mean)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
library(dplyr)
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
# integrate date to dataset: making time series
# hereby the table needs to be transposed temporarily as `xts()` orders by rows
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t() %>%
as.data.frame()
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
source('D:/Geodaten/#Jupiter/GEO402/project/402slangbos/import_parse.R', echo=TRUE)
# integrate date to dataset: making time series
# hereby the table needs to be transposed temporarily as `xts()` orders by rows
date_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
t() %>%
as.data.frame()
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
date_grouped_df = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
# calculating the mean and margins (stdev), one transposition needed here (better this way?)
a = df %>%
t() %>%
xts(order.by = date_s1) %>%
as.data.frame()
a
View(a)
map(a, mean)
map_df(a, mean)
map_df(a, median)
map_dbl(a, median)
map(a)
map(a, a*2)
map_dbl(a, a*2)
map_df(a, a*2)
map_dbl(a, median)
head(a)
map_dbl(a, median)
