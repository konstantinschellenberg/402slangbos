linevh.fmt = list(dash="solid", width = 1.5, color="blue")
# interval.fmt = list(dash="dot", width = 1, color="grey")
# save stats of vv and vh
x_vv = vv_plot$date
med_vv = vv_plot$median
losd_vv = vv_plot$lower_sd
upsd_vv = vv_plot$upper_sd
x_vh = vh_plot$date
med_vh = vh_plot$median
losd_vh = vh_plot$lower_sd
upsd_vh = vh_plot$upper_sd
# smoothing curve
pr_vv = supsmu(x_vv, med_vv)
pr_vh = supsmu(x_vh, med_vh)
# making smoothed line for standard deviation
# pr_losd = supsmu(x, losd)
# pr_upsd = supsmu(x, upsd)
# PLOTLY--------------------------------------------------------------------------
plt = plot_ly(data = vv_plot,
x = ~date,
y = ~median,
type = 'scatter',
line = data.fmt,
mode = "lines")
# name = paste(codename))
plt = plotly::layout(plt, title = paste0("Median Backscatter for site no. ", code," ", "_", stelle, ": ", namer(code)),
yaxis = list(range = c(-27, -8)))
plt = add_lines(plt,
x = x_vv,
y = pr_vv$y,
line = linevv.fmt,
name = "Smooth VV",
)
# plt = add_lines(plt, x = x, y = pr_losd$y, line = interval.fmt, name = "Lower standard deviation")
# plt = add_lines(plt, x = x, y = pr_upsd$y, line = interval.fmt, name = "Upper standard deviation")
plt = add_ribbons(plt, x = x_vv, ymin = losd_vv, ymax = upsd_vv,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VV 1 sigma standard deviation")
## add vh
plt = add_lines(plt,
x = x_vh,
y = med_vh,
name = "VH")
plt = add_lines(plt,
x = x_vh,
y = pr_vh$y,
line = linevh.fmt,
name = "Smooth VH")
plt = add_ribbons(plt, x = x_vh, ymin = losd_vh, ymax = upsd_vh,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VH 1 sigma standard deviation")
print(plt)
# exporting graphics to dst
# plotly::orca(plt, "D:\\Geodaten\\#Jupiter\\GEO402\\work progress\\plotly")
source('D:/Geodaten/Master/projects/402slangbos/import_parse.R', echo=TRUE)
stelle = 2
code = 3
# get roi
example = roi %>%
filter(roi$Name == code) %>%
.[stelle, ]
plot(example[1])
################ unbedingt besser coden!!
vv_grep = vv[grepl(paste0("plot", code, "_"), names(vv))]
# indexing
vv_fetched = vv_grep[[stelle]]
# remove na
vv_plot = na.omit(vv_fetched)
nrow(vv_plot)
vh_grep = vh[grepl(paste0("plot", code, "_"), names(vv))]
# indexing
vh_fetched = vh_grep[[stelle]]
# remove na
vh_plot = na.omit(vh_fetched)
nrow(vh_plot)
# ------------------------------------------------------------------------------
# format edits
data.fmt = list(color="#878787", width=1)
linevv.fmt = list(dash="solid", width = 1.5, color="red")
linevh.fmt = list(dash="solid", width = 1.5, color="blue")
# interval.fmt = list(dash="dot", width = 1, color="grey")
# save stats of vv and vh
x_vv = vv_plot$date
med_vv = vv_plot$median
losd_vv = vv_plot$lower_sd
upsd_vv = vv_plot$upper_sd
x_vh = vh_plot$date
med_vh = vh_plot$median
losd_vh = vh_plot$lower_sd
upsd_vh = vh_plot$upper_sd
# smoothing curve
pr_vv = supsmu(x_vv, med_vv)
pr_vh = supsmu(x_vh, med_vh)
# making smoothed line for standard deviation
# pr_losd = supsmu(x, losd)
# pr_upsd = supsmu(x, upsd)
# PLOTLY--------------------------------------------------------------------------
plt = plot_ly(data = vv_plot,
x = ~date,
y = ~median,
type = 'scatter',
line = data.fmt,
mode = "lines")
# name = paste(codename))
plt = plotly::layout(plt, title = paste0("Median Backscatter for site no. ", code," ", "_", stelle, ": ", namer(code)),
yaxis = list(range = c(-27, -8)))
plt = add_lines(plt,
x = x_vv,
y = pr_vv$y,
line = linevv.fmt,
name = "Smooth VV",
)
# plt = add_lines(plt, x = x, y = pr_losd$y, line = interval.fmt, name = "Lower standard deviation")
# plt = add_lines(plt, x = x, y = pr_upsd$y, line = interval.fmt, name = "Upper standard deviation")
plt = add_ribbons(plt, x = x_vv, ymin = losd_vv, ymax = upsd_vv,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VV 1 sigma standard deviation")
## add vh
plt = add_lines(plt,
x = x_vh,
y = med_vh,
name = "VH")
plt = add_lines(plt,
x = x_vh,
y = pr_vh$y,
line = linevh.fmt,
name = "Smooth VH")
plt = add_ribbons(plt, x = x_vh, ymin = losd_vh, ymax = upsd_vh,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VH 1 sigma standard deviation")
print(plt)
# exporting graphics to dst
stelle = 3
code = 3
# get roi
example = roi %>%
filter(roi$Name == code) %>%
.[stelle, ]
plot(example[1])
################ unbedingt besser coden!!
vv_grep = vv[grepl(paste0("plot", code, "_"), names(vv))]
# indexing
vv_fetched = vv_grep[[stelle]]
# remove na
vv_plot = na.omit(vv_fetched)
nrow(vv_plot)
vh_grep = vh[grepl(paste0("plot", code, "_"), names(vv))]
# indexing
vh_fetched = vh_grep[[stelle]]
# remove na
vh_plot = na.omit(vh_fetched)
nrow(vh_plot)
# ------------------------------------------------------------------------------
# format edits
data.fmt = list(color="#878787", width=1)
linevv.fmt = list(dash="solid", width = 1.5, color="red")
linevh.fmt = list(dash="solid", width = 1.5, color="blue")
# interval.fmt = list(dash="dot", width = 1, color="grey")
# save stats of vv and vh
x_vv = vv_plot$date
med_vv = vv_plot$median
losd_vv = vv_plot$lower_sd
upsd_vv = vv_plot$upper_sd
x_vh = vh_plot$date
med_vh = vh_plot$median
losd_vh = vh_plot$lower_sd
upsd_vh = vh_plot$upper_sd
# smoothing curve
pr_vv = supsmu(x_vv, med_vv)
pr_vh = supsmu(x_vh, med_vh)
# making smoothed line for standard deviation
# pr_losd = supsmu(x, losd)
# pr_upsd = supsmu(x, upsd)
# PLOTLY--------------------------------------------------------------------------
plt = plot_ly(data = vv_plot,
x = ~date,
y = ~median,
type = 'scatter',
line = data.fmt,
mode = "lines")
# name = paste(codename))
plt = plotly::layout(plt, title = paste0("Median Backscatter for site no. ", code," ", "_", stelle, ": ", namer(code)),
yaxis = list(range = c(-27, -8)))
plt = add_lines(plt,
x = x_vv,
y = pr_vv$y,
line = linevv.fmt,
name = "Smooth VV",
)
# plt = add_lines(plt, x = x, y = pr_losd$y, line = interval.fmt, name = "Lower standard deviation")
# plt = add_lines(plt, x = x, y = pr_upsd$y, line = interval.fmt, name = "Upper standard deviation")
plt = add_ribbons(plt, x = x_vv, ymin = losd_vv, ymax = upsd_vv,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VV 1 sigma standard deviation")
## add vh
plt = add_lines(plt,
x = x_vh,
y = med_vh,
name = "VH")
plt = add_lines(plt,
x = x_vh,
y = pr_vh$y,
line = linevh.fmt,
name = "Smooth VH")
plt = add_ribbons(plt, x = x_vh, ymin = losd_vh, ymax = upsd_vh,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VH 1 sigma standard deviation")
print(plt)
# exporting graphics to dst
# plotly::orca(plt, "D:\\Geodaten\\#Jupiter\\GEO402\\work progress\\plotly")
plot(example[1], main = paste0(code, " ", stelle)
plot(example[1], main = paste0(code, " ", stelle))
plot(example[1], main = paste0(codename, code, "_", stelle))
plot(example[1], main = paste0(namer(code), code, "_", stelle))
plot(example[1], main = paste0(namer(code), " ", code, "_", stelle))
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle))
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle), col = "greyy")
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle), col = "grey")
plot(s1vh[[1]])
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle), col = "grey")
plot(s1vh[[1]], add = T)
plot(s1vh[[1]], add = F)
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle), col = "grey")
vv
stelle = 1
code = 4
# get roi
example = roi %>%
filter(roi$Name == code) %>%
.[stelle, ]
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle), col = "grey")
plot(s1vh[[1]], add = F)
################ unbedingt besser coden!!
vv_grep = vv[grepl(paste0("plot", code, "_"), names(vv))]
# indexing
vv_fetched = vv_grep[[stelle]]
# remove na
vv_plot = na.omit(vv_fetched)
nrow(vv_plot)
vh_grep = vh[grepl(paste0("plot", code, "_"), names(vv))]
# indexing
vh_fetched = vh_grep[[stelle]]
# remove na
vh_plot = na.omit(vh_fetched)
nrow(vh_plot)
# ------------------------------------------------------------------------------
# format edits
data.fmt = list(color="#878787", width=1)
linevv.fmt = list(dash="solid", width = 1.5, color="red")
linevh.fmt = list(dash="solid", width = 1.5, color="blue")
# interval.fmt = list(dash="dot", width = 1, color="grey")
# save stats of vv and vh
x_vv = vv_plot$date
med_vv = vv_plot$median
losd_vv = vv_plot$lower_sd
upsd_vv = vv_plot$upper_sd
x_vh = vh_plot$date
med_vh = vh_plot$median
losd_vh = vh_plot$lower_sd
upsd_vh = vh_plot$upper_sd
# smoothing curve
pr_vv = supsmu(x_vv, med_vv)
pr_vh = supsmu(x_vh, med_vh)
# making smoothed line for standard deviation
# pr_losd = supsmu(x, losd)
# pr_upsd = supsmu(x, upsd)
# PLOTLY--------------------------------------------------------------------------
plt = plot_ly(data = vv_plot,
x = ~date,
y = ~median,
type = 'scatter',
line = data.fmt,
mode = "lines")
# name = paste(codename))
plt = plotly::layout(plt, title = paste0("Median Backscatter for site no. ", code," ", "_", stelle, ": ", namer(code)),
yaxis = list(range = c(-27, -8)))
plt = add_lines(plt,
x = x_vv,
y = pr_vv$y,
line = linevv.fmt,
name = "Smooth VV",
)
# plt = add_lines(plt, x = x, y = pr_losd$y, line = interval.fmt, name = "Lower standard deviation")
# plt = add_lines(plt, x = x, y = pr_upsd$y, line = interval.fmt, name = "Upper standard deviation")
plt = add_ribbons(plt, x = x_vv, ymin = losd_vv, ymax = upsd_vv,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VV 1 sigma standard deviation")
## add vh
plt = add_lines(plt,
x = x_vh,
y = med_vh,
name = "VH")
plt = add_lines(plt,
x = x_vh,
y = pr_vh$y,
line = linevh.fmt,
name = "Smooth VH")
plt = add_ribbons(plt, x = x_vh, ymin = losd_vh, ymax = upsd_vh,
color = I("grey80"), line = list(width = 0), opacity = 0.9,
name = "VH 1 sigma standard deviation")
print(plt)
# exporting graphics to dst
# get roi
example = roi %>%
filter(roi$Name == code) %>%
.[stelle, ]
plot(example[1], main = paste0(namer(code), ": ", code, "_", stelle), col = "grey")
plot(raster::extract(s1_vh[1], example)
)
plot(s1_vh[[1]], add = F)
plot(raster::extract(s1_vh[1], example))
plot(raster::extract(s1vh[1], example))
plot(raster::extract(s1vh[1], as.(example, "Spatial"))
plot(raster::extract(s1vh[1], as.(example, "Spatial")))
library(raster)
library(dplyr)
library(rgdal)
library(tidyverse)
library(magrittr)
library(sf)
library(purrr)
library(plotly)
library(processx)
library(latex2exp)
# try writing function
# import data
s1_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VH_free_state_study_area_geo402"
s1 = brick(s1_path)
s1
class(s1)
roi_path = "D:\\Geodaten\\#Jupiter\\GEO402\\02_features\\ROI_updated.kml"
roi_sp = readOGR(roi_path, "ROI_updated")
roi
roi = roi_sp %>%
st_as_sf() %>%
st_transform(st_crs(s1))
roi
# set crs(roi) to the crs(s1) brick. Remove Z-Dimension
roi = st_transform(roi_sf, st_crs(s1vv)) %>%
st_zm(drop = TRUE)
class(roi)
crs(roi)
library(raster)
library(dplyr)
library(rgdal)
library(tidyverse)
library(magrittr)
library(sf)
library(purrr)
library(plotly)
library(processx)
library(latex2exp)
# try writing function
# import data
s1_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VH_free_state_study_area_geo402"
s1 = brick(s1_path)
roi_path = "D:\\Geodaten\\#Jupiter\\GEO402\\02_features\\ROI_updated.kml"
roi_sp = readOGR(roi_path, "ROI_updated")
roi = roi_sp %>%
st_as_sf() %>%
st_transform(st_crs(s1))
df_summary = carve_brick(sentinel1_brick = s1vv,
polygon = roi,
code = 2,
roi_example_no = 1)
# Konstantin Schellenberg, WS 2019/20
# University of Jena, Chair of remote sensing
# supervisor: Dr. Marcel Urban
# This script serves to read Sentinel-1 Radar time series in order to extract region of interest (ROI)
# Functions are written to simplify the usage and enhance debugging
#
# 1. carve_brick:
# Reads s1 and roi, extracts "carves" the polygons in the raster brick and calculates some basic stats (mean, median, stdev)
#
# 2. list_summaries:
# Takes s1 and roi data, calls carve_brick and appends each retrieved dataframe-summary to a created list "summary"
# Prerequisits:
# Sentinel-1 time-stack
# Polygons of the region of interest (ROI) with the follwing column:
# name
# can have categories:
#     1 == slangbos encroachment, increase
#     12 == encroachment with cleaning/breakpoint
#     2 == cleaning/breakpoint
#     3 == continous persistance of slangbos
#     4 == agricultural site
# load required packages
library(raster)
library(dplyr)
library(rgdal)
library(tidyverse)
library(magrittr)
library(sf)
library(purrr)
library(plotly)
library(processx)
library(latex2exp)
################################################################################
# Import Sentinel-1 time series data--------------------------------------------
################################################################################
# windows
s1vv_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VV_free_state_study_area_geo402"
s1vh_path = "D:\\Geodaten\\#Jupiter\\GEO402\\01_data\\s1_data\\S1_A_D_VH_free_state_study_area_geo402"
# linux
# s1_path = "/home/aleko-kon/Dokumente/402_outdated/GEO402/01_Daten/s1_data/S1_A_D_VH_free_state_study_area_geo402"
s1vv = brick(s1vv_path)
s1vh = brick(s1vh_path)
crs(s1vv)
ncell(s1vv)
dim(s1vv)
res(s1vv)
nlayers(s1vv)
################################################################################
# Import ROIs-------------------------------------------------------------------
################################################################################
# windows
roi_path = "D:\\Geodaten\\#Jupiter\\GEO402\\02_features\\ROI_updated.kml"
# linux
# roi_path = "/home/aleko-kon/Dokumente/402_outdated/GEO402/ROI_updated.kml"
roi_sf = st_read(roi_path) # read in
# set crs(roi) to the crs(s1) brick. Remove Z-Dimension
roi = st_transform(roi_sf, st_crs(s1vv)) %>%
st_zm(drop = TRUE)
class(roi)
crs(roi)
# check if class is sf, crs is South African projection
################################################################################
# Function definition `carve_brick`---------------------------------------------
################################################################################
carve_brick = function(sentinel1_brick,
polygon,
code = 1,
roi_example_no = 1){
# built-in function for naming rois
namer <<- function(code){
codename = ""
# looping for plotting name
if (code == 1) {
codename = "Increase"
}
if (code == 2) {
codename = "Cleaned"
}
if (code == 12) {
codename = "Increase, then cleaned"
}
if (code == 3) {
codename = "Continuous"
}
if (code == 4) {
codename = "Agriculture"
}
return(codename)
}
# filtering code
roi_code = filter(polygon, polygon$Name == code)
# indexing single object
single_roi = roi_code[roi_example_no, 1]
# spatial subset with single ROI bounds
subset = raster::extract(sentinel1_brick, single_roi) %>%
as.data.frame()
# convert band names to date
bandnames = names(subset)
# iterate for date in column-names
for (i in bandnames){
date = substr(bandnames,13,20)
}
# convert date string into R date-time format
date_s1 = c()
for (i in 1:length(date)){
date_s1 <- append(date_s1, as.POSIXct(date[i], format = "%Y%m%d")) #https://www.statmethods.net/input/dates.html
}
####
datenames <<- date_s1
# integrate date to dataset: making time series
# calculating the mean and margins (stdev), one transposition t() needed here
df_date = subset %>%
t() %>%
as.data.frame() %>%
mutate(date = date_s1) #%>%
# na.omit()
df = pivot_longer(df_date,
-date,
names_to = "names",
values_to = "values"
)
df_summary = df %>%
group_by(date) %>%
summarise(mean = mean(values),
median = median(values),
sd = sd(values),
"lower_sd" = mean(values) - sd(values),
"upper_sd" = mean(values) + sd(values))
# printing summary to console
paste = paste(
paste("Size of the plot:", st_area(single_roi[1,]), sep = " "),
paste("count of pixel in the timestack:", nrow(df), sep = " "),
paste("ROI of type: ", namer(code), sep = " "),
paste("median = ", mean(df_summary$median, na.rm = TRUE), sep = " "),
paste("mean = ", mean(df_summary$mean, na.rm = TRUE), sep = " "),
paste("standard deviation = ", mean(df_summary$sd, na.rm = TRUE), "\n", sep = " "),
sep = "\n")
####
cat(paste)
return(df_summary)
}
# how-to-call
df_summary = carve_brick(sentinel1_brick = s1vv,
polygon = roi,
code = 2,
roi_example_no = 1)
df_summary
